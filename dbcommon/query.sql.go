// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package dbcommon

import (
	"context"
	"database/sql"
	"time"
)

const createAuthorizeSession = `-- name: CreateAuthorizeSession :exec
INSERT INTO sessions (auth_code, client_id, pkce_challenge, pkce_challenge_method, state, redirect_uri, expires_at, session_id)
VALUES (?, ?, ?, ?, ?, ?, NOW() + INTERVAL 10 MINUTE, UUID_TO_BIN(UUID()))
`

type CreateAuthorizeSessionParams struct {
	AuthCode            string
	ClientID            int64
	PkceChallenge       string
	PkceChallengeMethod string
	State               string
	RedirectUri         string
}

func (q *Queries) CreateAuthorizeSession(ctx context.Context, arg CreateAuthorizeSessionParams) error {
	_, err := q.db.ExecContext(ctx, createAuthorizeSession,
		arg.AuthCode,
		arg.ClientID,
		arg.PkceChallenge,
		arg.PkceChallengeMethod,
		arg.State,
		arg.RedirectUri,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (email, password) VALUES (?, ?)
`

type CreateUserParams struct {
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.Email, arg.Password)
	return err
}

const createUserSession = `-- name: CreateUserSession :execresult
INSERT INTO sessions (session_id, user_id, expires_at)
VALUES (UUID_TO_BIN(UUID()), ?, NOW() + INTERVAL 24 HOUR)
`

func (q *Queries) CreateUserSession(ctx context.Context, userID sql.NullInt64) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserSession, userID)
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE auth_code = ?
`

func (q *Queries) DeleteSession(ctx context.Context, authCode string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, authCode)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
DELETE FROM sessions WHERE session_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteUserSession(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteUserSession, uuidTOBIN)
	return err
}

const getClientByID = `-- name: GetClientByID :one
SELECT id, namespace, name, created_at FROM clients WHERE id = ?
`

func (q *Queries) GetClientByID(ctx context.Context, id int64) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByID, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getClientByNamespace = `-- name: GetClientByNamespace :one
SELECT id, namespace, name, created_at FROM clients WHERE namespace = ?
`

func (q *Queries) GetClientByNamespace(ctx context.Context, namespace string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByNamespace, namespace)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByAuthCode = `-- name: GetSessionByAuthCode :one
SELECT s.id, s.session_id, s.user_id, s.auth_code, s.client_id, s.pkce_challenge, s.pkce_challenge_method, s.state, s.redirect_uri, s.created_at, s.expires_at, u.email as user_email
FROM sessions s
LEFT JOIN users u ON s.user_id = u.id
WHERE s.auth_code = ?
`

type GetSessionByAuthCodeRow struct {
	ID                  int64
	SessionID           []byte
	UserID              sql.NullInt64
	AuthCode            string
	ClientID            int64
	PkceChallenge       string
	PkceChallengeMethod string
	State               string
	RedirectUri         string
	CreatedAt           sql.NullTime
	ExpiresAt           time.Time
	UserEmail           sql.NullString
}

func (q *Queries) GetSessionByAuthCode(ctx context.Context, authCode string) (GetSessionByAuthCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionByAuthCode, authCode)
	var i GetSessionByAuthCodeRow
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.AuthCode,
		&i.ClientID,
		&i.PkceChallenge,
		&i.PkceChallengeMethod,
		&i.State,
		&i.RedirectUri,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UserEmail,
	)
	return i, err
}

const getUserByAuthCode = `-- name: GetUserByAuthCode :one
SELECT u.id, u.email, u.password 
FROM users u
JOIN sessions s ON u.id = s.user_id
WHERE s.auth_code = ?
`

func (q *Queries) GetUserByAuthCode(ctx context.Context, authCode string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByAuthCode, authCode)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.Password)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password FROM users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.Password)
	return i, err
}

const getUserSession = `-- name: GetUserSession :one
SELECT s.id, s.user_id, s.expires_at, u.email as user_email
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.session_id = UUID_TO_BIN(?)
`

type GetUserSessionRow struct {
	ID        int64
	UserID    sql.NullInt64
	ExpiresAt time.Time
	UserEmail string
}

func (q *Queries) GetUserSession(ctx context.Context, uuidTOBIN string) (GetUserSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getUserSession, uuidTOBIN)
	var i GetUserSessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExpiresAt,
		&i.UserEmail,
	)
	return i, err
}

const getUserSessionByUserID = `-- name: GetUserSessionByUserID :one
SELECT s.id, BIN_TO_UUID(s.session_id) as session_id, s.user_id, s.expires_at, u.email as user_email
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.user_id = ?
ORDER BY s.created_at DESC LIMIT 1
`

type GetUserSessionByUserIDRow struct {
	ID        int64
	SessionID string
	UserID    sql.NullInt64
	ExpiresAt time.Time
	UserEmail string
}

func (q *Queries) GetUserSessionByUserID(ctx context.Context, userID sql.NullInt64) (GetUserSessionByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserSessionByUserID, userID)
	var i GetUserSessionByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.ExpiresAt,
		&i.UserEmail,
	)
	return i, err
}

const updateUserSession = `-- name: UpdateUserSession :exec
UPDATE sessions 
SET user_id = ?
WHERE auth_code = ?
`

type UpdateUserSessionParams struct {
	UserID   sql.NullInt64
	AuthCode string
}

func (q *Queries) UpdateUserSession(ctx context.Context, arg UpdateUserSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSession, arg.UserID, arg.AuthCode)
	return err
}
